# Getting Started: A Sidebar

So, over in the other text we've talked about how to get your project started conceptually. We also need to get the project, well, _started_. Where's the code, where are we going to do the work?

So, let's look at that.

There are some very basic things we need to do just to get started, and most of them are best done from the command line. 

> Not comfortable with the command line? <Yoda>You will be. You will be.</Yoda> 

So, open your favorite terminal application, and navigate to where you keep your working files.  I _always_ put _everything_ in my Dropbox, so that it's available across my different machines and always backed up. Of course, I also put my code into Github or Bitbucket or Gitlab. And I wear suspenders and a belt.

I have a directory where I put these kind of learning projects in my Dropbox: `/Users/chasrmartin/Dropbox/Etudes/`. This is an Angular project, which I keep in a subdirectory named, you guessed it, `Angular`. And this project will be called Fisheries, so we create a directory `Fisheries`. So we start like this:

```bash
$ cd /Users/chasrmartin/Dropbox/Etudes/Angular/
$ mkdir Fisheries && cd $_
```

> Command line hints:  
> 1. You can abbreviate the cd to `~/Dropbox/Etudes/Angular/`
> 2. `mkdir Fisheries && cd $_` means "first make a directory named `Fisheries`, and then if that works (`&&`) cd to the directory that was named as the most recent parameter (`$_`)

Now that we're here, we need to get started setting up for an Angular app. We want to _first_ prepare the directory for a node server, and then _second_ we want to create our Git repository for the code.

Why? Simple: when we set up the node app we're going to create some initial files. We might as well set them up and put them in the inital commit.

> Actually, there are a number of tools that can set up a whole environment using templates or boilerplate code, like [bower](https://bower.io/) and [yeoman](http://yeoman.io/). but those environments set up fairly complicated full-fledged applications. For this project, we're going to set up something a little simpler.

One of the peculiarities of Git is that it doesn't want to add empty directories to the repository. While there are [ways around this limitation](http://stackoverflow.com/questions/115983/how-can-i-add-an-empty-directory-to-a-git-repository), frankly they're more trouble than they're worth.  Instead, we'll just use _touch(1)_ to create some empty files, which Git is perfectly okay with.

```shell
$ mkdir -p app/js server public/css 
$ touch app/js/index.js 
$ touch server/server.js 
$ touch public/index.html public/css/main.css
```

Now we have our directory set up, so we can initialize things.

> I also created a directory `docs`, which contains -- among other things -- the document you're reading now.
> ```shell
> $ mkdir docs
> ```

First, we initialize the node application using `npm init`:

```shell
$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help json` for definitive documentation on these fields
and exactly what they do.

Use `npm install <pkg> --save` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
name: (Fisheries) fisheries
version: (1.0.0) 0.0.0
description: An MVP web app for fishermen, retrieving, storing and (perhaps) sharing information about time and tides, location, catch, and user-defined notes.
entry point: (index.js) app/js/app.js
test command:
git repository:
keywords:
author: Charlie Martin chasrmartin@refactoru.com
license: (ISC)
About to write to /Users/chasrmartin/Dropbox/Etudes/Angular/Fisheries/package.json:

{
  "name": "fisheries",
  "version": "0.1.0",
  "description": "An MVP web app for fishermen, retrieving, storing and (perhaps) sharing information about time and tides, location, catch, and user-defined notes.",
  "main": "app/js/app.js",
  "directories": {
    "doc": "docs"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Charlie Martin chasrmartin@refactoru.com",
  "license": "ISC"
}


Is this ok? (yes)
$
```

This is all pretty much boilerplate generated by _npm_. It goes into the file `package.json`, which npm puts into the directory in which you ran it. You can see the package.json it generated in the response above. The one thing to pay attention to right now is the version number. This will eventually become important, though, so let's discuss it quickly.

There is a standard called [semantic versioning](http://semver.org/) which is commonly used for version numbers. Follow that link for details, but the basic idea is that it's three numbers:

* The _major version_,
* the _minor version_, and 
* the _patch level_.

The first _released_ version is 1.0.0. The major version changes when changes are made that are backward-incompatible; we can't be backward incompatible to something that doesn't exist, so with start with a major version of `0`. It doesn't have any features at all, so the minor version is `0`. And there are no patch numbers, so the patch number is `0`. 

> __Warning__: I asked three people and got _n_ > 3 opinions on this. So I'm picking one I think makes sense, and your mileage may vary.

We've now got a basic package setup for Node, and we're ready to prepare the first commit for git. This (at last) is really easy.

First go to your Github account, log in, and set up a new repository:

((screen cap here))

Initialize the repository and add a `.gitignore` file. We'll look at that in a minute.

((screen cap here))

Push the green button and there you are.

((screen cap here))

We now have a repository on GitHub; we want to create a repository locally and connect the GitHub repository as a remote repository.

Create the repository:

```shell
$ git init
```

After the Git init, you're whole directory tree will look like:

```shell
$ tree -a
.
├── .DS_Store
├── .git
│   ├── HEAD
│   ├── branches
│   ├── config
│   ├── description
│   ├── hooks
│   │   ├── applypatch-msg.sample
│   │   ├── commit-msg.sample
│   │   ├── post-update.sample
│   │   ├── pre-applypatch.sample
│   │   ├── pre-commit.sample
│   │   ├── pre-push.sample
│   │   ├── pre-rebase.sample
│   │   ├── prepare-commit-msg.sample
│   │   └── update.sample
│   ├── info
│   │   └── exclude
│   ├── objects
│   │   ├── info
│   │   └── pack
│   └── refs
│       ├── heads
│       └── tags
├── .gitignore
├── app
│   └── js
│       └── app.js
├── docs
│   ├── TinyMethodology.docx
│   └── gettingStartedSidebar.md
├── package.json
├── public
│   ├── css
│   │   └── main.css
│   └── index.html
├── readme.md
└── server
    └── server.js
```

You can see that this created a directory named `.git` with a whole lot of stuff in it, none of which we really care about now, so we'll ignore it. The important thing for now is that our app has a `.git` directory, which means it now has a local git repository.

We now want to connect it with our GitHub repository. To do that, go back to your GitHub web page for the repository.

((screen cap here))

Click the "Clone or Download" button, and then click the little clipboard icon, and the URL for your repository will be copied to your clipboard. Mine is `https://github.com/chasrmartin/Fisheries.git`. 

We add that repository as a remove repository named "origin" to our existing repository:

```shell
$ git remote add origin https://github.com/chasrmartin/Fisheries.git
```

Then `git remote -v` shows that the remote is there.

``` shell
$ git remote -v
origin	https://github.com/chasrmartin/Fisheries.git (fetch)
origin	https://github.com/chasrmartin/Fisheries.git (push)
$
```

Don't despair, we're almost done. The last thing we want to do is pull the remote repo so our local copy matches the remote we created. We're getting the two of them in sync.

```shell
$ git pull origin master
$ git push origin master
```

# Review

> **To Do**


